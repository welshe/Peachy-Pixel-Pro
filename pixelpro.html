<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Peachy Pixel Pro</title>
    <style>
        :root {
            --primary-color: #FF9E80;
            --secondary-color: #4CAF50;
            --tertiary-color: #2196F3;
            --dark-bg: #222;
            --medium-bg: #333;
            --light-bg: #444;
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background-color: var(--dark-bg);
            color: #eee;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            width: 100%;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: var(--primary-color);
            text-shadow: 0 0 10px rgba(255, 158, 128, 0.5);
            font-size: 2.5rem;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 30px;
            padding: 20px;
            background-color: var(--medium-bg);
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            justify-content: center;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 150px;
        }

        label {
            font-size: 14px;
            color: #aaa;
        }

        input[type="text"] {
            padding: 12px;
            border: 2px solid var(--light-bg);
            border-radius: 6px;
            background-color: var(--light-bg);
            color: #fff;
            font-size: 16px;
            width: 100%;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        input[type="range"] {
            width: 100%;
        }

        .value-display {
            font-size: 14px;
            color: var(--primary-color);
            text-align: center;
            font-weight: bold;
        }

        button {
            padding: 12px 18px;
            background-color: var(--primary-color);
            color: #333;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            width: 100%;
        }

        button:hover {
            background-color: #FF8A65;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .secondary-btn {
            background-color: var(--secondary-color);
            color: white;
        }

        .secondary-btn:hover {
            background-color: #45a049;
        }

        .tertiary-btn {
            background-color: var(--tertiary-color);
            color: white;
        }

        .tertiary-btn:hover {
            background-color: #0b7dda;
        }

        .quaternary-btn {
            background-color: #9C27B0;
            color: white;
        }

        .quaternary-btn:hover {
            background-color: #7B1FA2;
        }

        .quinary-btn {
            background-color: #FF5722;
            color: white;
        }

        .quinary-btn:hover {
            background-color: #E64A19;
        }

        .senary-btn {
            background-color: #009688;
            color: white;
        }

        .senary-btn:hover {
            background-color: #00796B;
        }

        .grid-container {
            display: flex;
            justify-content: center;
            margin-top: 20px;
            overflow: auto;
            padding: 20px;
            background-color: var(--medium-bg);
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            position: relative;
            max-width: 100%;
        }

        .pixel-grid {
            display: grid;
            gap: 1px;
            background-color: #555;
            padding: 10px;
            border-radius: 6px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            transform-origin: center center;
        }

        .pixel {
            width: var(--pixel-size);
            height: var(--pixel-size);
            background-color: var(--bg-color, var(--light-bg));
            border-radius: 1px;
            transition: background-color 0.2s;
            opacity: 0;
            animation: fadeIn 0.3s forwards;
        }

        @keyframes fadeIn {
            to {
                opacity: 1;
            }
        }

        @keyframes wave {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        @keyframes glow {
            0%, 100% { box-shadow: 0 0 3px rgba(255, 255, 255, 0.3); }
            50% { box-shadow: 0 0 15px rgba(255, 158, 128, 0.8); }
        }

        .pixel.filled {
            background-color: var(--text-color, var(--primary-color));
            box-shadow: 0 0 3px rgba(255, 255, 255, 0.3);
        }

        .pixel.wave {
            animation: wave 1s infinite;
        }

        .pixel.pulse {
            animation: pulse 1s infinite;
        }

        .pixel.glow {
            animation: glow 1.5s infinite;
        }

        .color-picker {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        input[type="color"] {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .copy-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: var(--primary-color);
            color: #333;
            padding: 10px 20px;
            border-radius: 6px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1000;
            font-weight: bold;
        }

        .copy-notification.show {
            opacity: 1;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .toggle {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--light-bg);
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--primary-color);
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .hidden {
            display: none;
        }

        .ascii-output {
            margin-top: 20px;
            padding: 15px;
            background-color: var(--medium-bg);
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            display: none;
            width: 100%;
        }

        .ascii-output h3 {
            margin-top: 0;
            color: var(--primary-color);
        }

        .ascii-output pre {
            background-color: var(--light-bg);
            padding: 15px;
            border-radius: 6px;
            overflow: auto;
            font-size: 14px;
            line-height: 1.2;
            white-space: pre;
            color: #fff;
            border: 1px solid #555;
        }

        .gallery {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
            padding: 15px;
            background-color: var(--medium-bg);
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .gallery-item {
            width: 80px;
            height: 80px;
            background-color: var(--light-bg);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 10px;
            text-align: center;
        }

        .gallery-item:hover {
            background-color: #555;
            transform: scale(1.05);
        }

        .history-panel {
            margin-top: 20px;
            padding: 15px;
            background-color: var(--medium-bg);
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            display: none;
        }

        .history-panel h3 {
            margin-top: 0;
            color: var(--primary-color);
        }

        .history-item {
            padding: 10px;
            background-color: var(--light-bg);
            border-radius: 6px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .history-item button {
            padding: 5px 10px;
            font-size: 14px;
        }

        .custom-char-editor {
            margin-top: 20px;
            padding: 15px;
            background-color: var(--medium-bg);
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            display: none;
        }

        .custom-char-editor h3 {
            margin-top: 0;
            color: var(--primary-color);
        }

        .char-grid {
            display: grid;
            grid-template-columns: repeat(5, 30px);
            grid-template-rows: repeat(7, 30px);
            gap: 1px;
            background-color: #555;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 15px;
        }

        .char-pixel {
            width: 30px;
            height: 30px;
            background-color: var(--light-bg);
            border-radius: 2px;
            cursor: pointer;
        }

        .char-pixel.filled {
            background-color: var(--primary-color);
        }

        .fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--dark-bg);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .fullscreen .grid-container {
            max-width: 90%;
            max-height: 90%;
        }

        .fullscreen .exit-fullscreen {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 2001;
        }

        .gradient-preview {
            width: 100%;
            height: 20px;
            border-radius: 4px;
            margin-top: 5px;
        }

        .tab-container {
            margin-top: 20px;
            background-color: var(--medium-bg);
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            width: 100%;
        }

        .tab-buttons {
            display: flex;
            border-bottom: 1px solid var(--light-bg);
            flex-wrap: wrap;
        }

        .tab-button {
            padding: 10px 20px;
            background-color: var(--medium-bg);
            color: #aaa;
            border: none;
            cursor: pointer;
            transition: all 0.3s;
            flex: 1;
            min-width: 120px;
        }

        .tab-button.active {
            background-color: var(--light-bg);
            color: var(--primary-color);
        }

        .tab-content {
            padding: 20px;
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .palette-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .palette-color {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .palette-color:hover {
            transform: scale(1.1);
        }

        .batch-textarea {
            width: 100%;
            min-height: 150px;
            padding: 10px;
            background-color: var(--light-bg);
            color: #fff;
            border: none;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            margin-bottom: 15px;
        }

        .batch-results {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 15px;
        }

        .batch-item {
            background-color: var(--light-bg);
            border-radius: 6px;
            padding: 10px;
            text-align: center;
        }

        .batch-item .pixel-grid {
            margin-bottom: 10px;
        }

        /* New styles for improvements and features */
        
        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .controls {
                padding: 15px;
            }
            
            .input-group {
                min-width: 100%;
            }
            
            .tab-buttons {
                flex-direction: column;
            }
            
            .tab-button {
                min-width: 100%;
            }
            
            h1 {
                font-size: 1.8rem;
            }
        }

        /* Color palette */
        .color-palette {
            margin-top: 15px;
            padding: 15px;
            background-color: var(--light-bg);
            border-radius: 6px;
        }

        .color-palette h4 {
            margin-top: 0;
            color: var(--primary-color);
        }

        /* Text shadow controls */
        .shadow-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        .shadow-control {
            flex: 1;
            min-width: 80px;
        }

        /* Character spacing visualization */
        .spacing-visualization {
            height: 20px;
            background-color: var(--light-bg);
            border-radius: 4px;
            margin-top: 5px;
            position: relative;
            overflow: hidden;
        }

        .spacing-bar {
            height: 100%;
            background-color: var(--primary-color);
            position: absolute;
            top: 0;
            left: 0;
            transition: width 0.3s;
        }

        /* Auto-save indicator */
        .auto-save-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            font-size: 14px;
            color: #aaa;
        }

        .save-status {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #4CAF50;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .save-status.saving {
            opacity: 1;
            animation: pulse 1s infinite;
        }

        /* Error message */
        .error-message {
            color: #ff5252;
            font-size: 14px;
            margin-top: 5px;
            display: none;
        }

        /* Feature highlights */
        .feature-highlight {
            background-color: rgba(255, 158, 128, 0.1);
            border-left: 3px solid var(--primary-color);
            padding: 10px 15px;
            margin: 10px 0;
            border-radius: 0 4px 4px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Peachy Pixel Pro</h1>
        
        <div class="controls">
            <div class="input-group">
                <label for="textInput">Enter Text:</label>
                <input type="text" id="textInput" placeholder="Type something..." value="HELLO" maxlength="50">
                <div class="error-message" id="textError">Text is too long! Maximum 50 characters.</div>
            </div>
            
            <div class="input-group">
                <label for="zoomSlider">Zoom:</label>
                <input type="range" id="zoomSlider" min="1" max="10" value="3">
                <div class="value-display" id="zoomValue">3x</div>
            </div>
            
            <div class="input-group">
                <label for="pixelDensitySlider">Pixel Density:</label>
                <input type="range" id="pixelDensitySlider" min="1" max="5" value="1">
                <div class="value-display" id="pixelDensityValue">1x</div>
            </div>
            
            <div class="input-group">
                <label for="charSpacingSlider">Character Spacing:</label>
                <input type="range" id="charSpacingSlider" min="0" max="5" value="1">
                <div class="value-display" id="charSpacingValue">1</div>
                <div class="spacing-visualization">
                    <div class="spacing-bar" id="spacingBar"></div>
                </div>
            </div>
            
            <div class="input-group">
                <label for="lineHeightSlider">Line Height:</label>
                <input type="range" id="lineHeightSlider" min="0" max="5" value="0">
                <div class="value-display" id="lineHeightValue">0</div>
            </div>
            
            <div class="input-group">
                <label for="textColor">Text Color:</label>
                <div class="color-picker">
                    <input type="color" id="textColor" value="#FF9E80">
                </div>
            </div>
            
            <div class="input-group">
                <label for="bgColor">Background Color:</label>
                <div class="color-picker">
                    <input type="color" id="bgColor" value="#444444">
                </div>
            </div>
            
            <div class="input-group">
                <label>Grid Lines:</label>
                <div class="toggle-container">
                    <label class="toggle">
                        <input type="checkbox" id="gridToggle" checked>
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
            
            <div class="input-group">
                <label>Animation:</label>
                <div class="toggle-container">
                    <label class="toggle">
                        <input type="checkbox" id="animationToggle">
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
            
            <div class="input-group">
                <label>&nbsp;</label>
                <button id="generateBtn">Generate</button>
            </div>
            
            <div class="input-group">
                <label>&nbsp;</label>
                <button id="clearBtn" class="secondary-btn">Clear</button>
            </div>
            
            <div class="input-group">
                <label>&nbsp;</label>
                <button id="invertBtn" class="tertiary-btn">Invert Colors</button>
            </div>
            
            <div class="input-group">
                <label>&nbsp;</label>
                <button id="randomColorBtn" class="quaternary-btn">Random Colors</button>
            </div>
            
            <div class="input-group">
                <label>&nbsp;</label>
                <button id="savePngBtn">Save as PNG</button>
            </div>
            
            <div class="input-group">
                <label>&nbsp;</label>
                <button id="asciiBtn" class="secondary-btn">Export as ASCII</button>
            </div>
        </div>
        
        <div class="grid-container">
            <div class="pixel-grid" id="pixelGrid"></div>
        </div>
        
        <div class="tab-container">
            <div class="tab-buttons">
                <button class="tab-button active" data-tab="effects">Effects</button>
                <button class="tab-button" data-tab="gallery">Gallery</button>
                <button class="tab-button" data-tab="history">History</button>
                <button class="tab-button" data-tab="custom">Custom Character</button>
                <button class="tab-button" data-tab="advanced">Advanced</button>
            </div>
            
            <div class="tab-content active" id="effects-tab">
                <h3>Text Effects</h3>
                <div class="feature-highlight">
                    New: Enhanced text shadow controls for more customization options
                </div>
                <div class="controls">
                    <div class="input-group">
                        <label>Text Shadow:</label>
                        <div class="toggle-container">
                            <label class="toggle">
                                <input type="checkbox" id="shadowToggle">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                    
                    <div class="shadow-controls">
                        <div class="input-group shadow-control">
                            <label for="shadowX">Shadow X:</label>
                            <input type="range" id="shadowX" min="-10" max="10" value="2">
                            <div class="value-display" id="shadowXValue">2px</div>
                        </div>
                        
                        <div class="input-group shadow-control">
                            <label for="shadowY">Shadow Y:</label>
                            <input type="range" id="shadowY" min="-10" max="10" value="2">
                            <div class="value-display" id="shadowYValue">2px</div>
                        </div>
                        
                        <div class="input-group shadow-control">
                            <label for="shadowBlur">Shadow Blur:</label>
                            <input type="range" id="shadowBlur" min="0" max="20" value="4">
                            <div class="value-display" id="shadowBlurValue">4px</div>
                        </div>
                    </div>
                    
                    <div class="input-group">
                        <label>Shadow Color:</label>
                        <div class="color-picker">
                            <input type="color" id="shadowColor" value="#000000">
                        </div>
                    </div>
                    
                    <div class="input-group">
                        <label>Rotation:</label>
                        <select id="rotationSelect">
                            <option value="0">0째</option>
                            <option value="90">90째</option>
                            <option value="180">180째</option>
                            <option value="270">270째</option>
                        </select>
                    </div>
                    
                    <div class="input-group">
                        <label>Mirror:</label>
                        <select id="mirrorSelect">
                            <option value="none">None</option>
                            <option value="horizontal">Horizontal</option>
                            <option value="vertical">Vertical</option>
                            <option value="both">Both</option>
                        </select>
                    </div>
                    
                    <div class="input-group">
                        <label>Gradient:</label>
                        <div class="toggle-container">
                            <label class="toggle">
                                <input type="checkbox" id="gradientToggle">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                    
                    <div class="input-group">
                        <label>Gradient End Color:</label>
                        <div class="color-picker">
                            <input type="color" id="gradientColor" value="#FF5722">
                        </div>
                        <div class="gradient-preview" id="gradientPreview"></div>
                    </div>
                    
                    <div class="input-group">
                        <label>Text Outline:</label>
                        <div class="toggle-container">
                            <label class="toggle">
                                <input type="checkbox" id="outlineToggle">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                    
                    <div class="input-group">
                        <label>Outline Color:</label>
                        <div class="color-picker">
                            <input type="color" id="outlineColor" value="#FFFFFF">
                        </div>
                    </div>
                    
                    <div class="input-group">
                        <label>Animation Type:</label>
                        <select id="animationType">
                            <option value="none">None</option>
                            <option value="wave">Wave</option>
                            <option value="pulse">Pulse</option>
                            <option value="glow">Glow</option>
                        </select>
                    </div>
                    
                    <div class="input-group">
                        <label>Animation Speed:</label>
                        <input type="range" id="animationSpeed" min="0.5" max="3" step="0.1" value="1">
                        <div class="value-display" id="animationSpeedValue">1x</div>
                    </div>
                    
                    <div class="input-group">
                        <label>Background Pattern:</label>
                        <select id="bgPattern">
                            <option value="none">None</option>
                            <option value="dots">Dots</option>
                            <option value="grid">Grid</option>
                            <option value="diagonal">Diagonal</option>
                        </select>
                    </div>
                    
                    <div class="input-group">
                        <label>Text Alignment:</label>
                        <select id="textAlign">
                            <option value="left">Left</option>
                            <option value="center">Center</option>
                            <option value="right">Right</option>
                        </select>
                    </div>
                </div>
                
                <div class="color-palette">
                    <h4>Color Palette</h4>
                    <div class="palette-grid" id="colorPalette">
                        <!-- Color palette will be generated dynamically -->
                    </div>
                </div>
            </div>
            
            <div class="tab-content" id="gallery-tab">
                <h3>Pixel Art Gallery</h3>
                <div class="gallery" id="gallery">
                    <!-- Gallery items will be added dynamically -->
                </div>
            </div>
            
            <div class="tab-content" id="history-tab">
                <h3>Text History</h3>
                <div class="auto-save-indicator">
                    <div class="save-status" id="saveStatus"></div>
                    <span id="autoSaveText">Auto-save: Off</span>
                </div>
                <div class="history-panel" id="historyPanel">
                    <!-- History items will be added dynamically -->
                </div>
            </div>
            
            <div class="tab-content" id="custom-tab">
                <h3>Custom Character Editor</h3>
                <div class="custom-char-editor" id="customCharEditor">
                    <div class="input-group">
                        <label for="customCharName">Character Name:</label>
                        <input type="text" id="customCharName" placeholder="Enter a name for your character">
                    </div>
                    <div class="char-grid" id="charGrid">
                        <!-- Character grid will be generated dynamically -->
                    </div>
                    <div class="input-group">
                        <label>&nbsp;</label>
                        <button id="saveCustomCharBtn">Save Character</button>
                    </div>
                </div>
            </div>
            
            <div class="tab-content" id="advanced-tab">
                <h3>Advanced Features</h3>
                <div class="feature-highlight">
                    New: Batch processing allows you to generate multiple texts at once
                </div>
                <div class="controls">
                    <div class="input-group">
                        <label>&nbsp;</label>
                        <button id="saveSvgBtn" class="tertiary-btn">Save as SVG</button>
                    </div>
                    
                    <div class="input-group">
                        <label>&nbsp;</label>
                        <button id="saveJsonBtn" class="quaternary-btn">Save as JSON</button>
                    </div>
                    
                    <div class="input-group">
                        <label>&nbsp;</label>
                        <button id="loadJsonBtn" class="quaternary-btn">Load from JSON</button>
                    </div>
                    
                    <div class="input-group">
                        <label>&nbsp;</label>
                        <button id="fullscreenBtn" class="senary-btn">Fullscreen Mode</button>
                    </div>
                    
                    <div class="input-group">
                        <label>Auto-save:</label>
                        <div class="toggle-container">
                            <label class="toggle">
                                <input type="checkbox" id="autoSaveToggle">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                    
                    <div class="input-group">
                        <label>&nbsp;</label>
                        <button id="batchProcessBtn" class="quinary-btn">Batch Process</button>
                    </div>
                </div>
                
                <div class="input-group" id="batchProcessSection" style="display: none; margin-top: 20px;">
                    <label>Enter Texts (one per line):</label>
                    <textarea class="batch-textarea" id="batchTexts" placeholder="Enter multiple texts, one per line"></textarea>
                    <button id="runBatchBtn">Process Batch</button>
                    <div class="batch-results" id="batchResults"></div>
                </div>
            </div>
        </div>
        
        <div class="ascii-output" id="asciiOutput">
            <h3>ASCII Art Representation</h3>
            <pre id="asciiRepresentation"></pre>
            <button id="copyAsciiBtn" class="secondary-btn">Copy ASCII</button>
        </div>
    </div>

    <div class="copy-notification" id="copyNotification">Image saved!</div>

    <script>
        // Define pixel alphabet (5x7 matrix for each character)
        const pixelAlphabet = {
            'A': [
                [0,1,1,1,0],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,1,1,1,1],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,0,0,0,1]
            ],
            'B': [
                [1,1,1,1,0],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,1,1,1,0],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,1,1,1,0]
            ],
            'C': [
                [0,1,1,1,0],
                [1,0,0,0,1],
                [1,0,0,0,0],
                [1,0,0,0,0],
                [1,0,0,0,0],
                [1,0,0,0,1],
                [0,1,1,1,0]
            ],
            'D': [
                [1,1,1,1,0],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,1,1,1,0]
            ],
            'E': [
                [1,1,1,1,1],
                [1,0,0,0,0],
                [1,0,0,0,0],
                [1,1,1,1,0],
                [1,0,0,0,0],
                [1,0,0,0,0],
                [1,1,1,1,1]
            ],
            'F': [
                [1,1,1,1,1],
                [1,0,0,0,0],
                [1,0,0,0,0],
                [1,1,1,1,0],
                [1,0,0,0,0],
                [1,0,0,0,0],
                [1,0,0,0,0]
            ],
            'G': [
                [0,1,1,1,0],
                [1,0,0,0,1],
                [1,0,0,0,0],
                [1,0,1,1,1],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [0,1,1,1,0]
            ],
            'H': [
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,1,1,1,1],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,0,0,0,1]
            ],
            'I': [
                [1,1,1,1,1],
                [0,0,1,0,0],
                [0,0,1,0,0],
                [0,0,1,0,0],
                [0,0,1,0,0],
                [0,0,1,0,0],
                [1,1,1,1,1]
            ],
            'J': [
                [1,1,1,1,1],
                [0,0,0,1,0],
                [0,0,0,1,0],
                [0,0,0,1,0],
                [0,0,0,1,0],
                [1,0,0,1,0],
                [0,1,1,0,0]
            ],
            'K': [
                [1,0,0,0,1],
                [1,0,0,1,0],
                [1,0,1,0,0],
                [1,1,0,0,0],
                [1,0,1,0,0],
                [1,0,0,1,0],
                [1,0,0,0,1]
            ],
            'L': [
                [1,0,0,0,0],
                [1,0,0,0,0],
                [1,0,0,0,0],
                [1,0,0,0,0],
                [1,0,0,0,0],
                [1,0,0,0,0],
                [1,1,1,1,1]
            ],
            'M': [
                [1,0,0,0,1],
                [1,1,0,1,1],
                [1,0,1,0,1],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,0,0,0,1]
            ],
            'N': [
                [1,0,0,0,1],
                [1,1,0,0,1],
                [1,0,1,0,1],
                [1,0,0,1,1],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,0,0,0,1]
            ],
            'O': [
                [0,1,1,1,0],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [0,1,1,1,0]
            ],
            'P': [
                [1,1,1,1,0],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,1,1,1,0],
                [1,0,0,0,0],
                [1,0,0,0,0],
                [1,0,0,0,0]
            ],
            'Q': [
                [0,1,1,1,0],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,0,1,0,1],
                [1,0,0,1,0],
                [0,1,1,0,1]
            ],
            'R': [
                [1,1,1,1,0],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,1,1,1,0],
                [1,0,1,0,0],
                [1,0,0,1,0],
                [1,0,0,0,1]
            ],
            'S': [
                [0,1,1,1,0],
                [1,0,0,0,1],
                [1,0,0,0,0],
                [0,1,1,1,0],
                [0,0,0,0,1],
                [1,0,0,0,1],
                [0,1,1,1,0]
            ],
            'T': [
                [1,1,1,1,1],
                [0,0,1,0,0],
                [0,0,1,0,0],
                [0,0,1,0,0],
                [0,0,1,0,0],
                [0,0,1,0,0],
                [0,0,1,0,0]
            ],
            'U': [
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [0,1,1,1,0]
            ],
            'V': [
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [0,1,0,1,0],
                [0,0,1,0,0]
            ],
            'W': [
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,0,1,0,1],
                [1,0,1,0,1],
                [1,1,0,1,1],
                [1,0,0,0,1]
            ],
            'X': [
                [1,0,0,0,1],
                [0,1,0,1,0],
                [0,0,1,0,0],
                [0,0,1,0,0],
                [0,0,1,0,0],
                [0,1,0,1,0],
                [1,0,0,0,1]
            ],
            'Y': [
                [1,0,0,0,1],
                [0,1,0,1,0],
                [0,0,1,0,0],
                [0,0,1,0,0],
                [0,0,1,0,0],
                [0,0,1,0,0],
                [0,0,1,0,0]
            ],
            'Z': [
                [1,1,1,1,1],
                [0,0,0,1,0],
                [0,0,1,0,0],
                [0,1,0,0,0],
                [1,0,0,0,0],
                [1,0,0,0,0],
                [1,1,1,1,1]
            ],
            ' ': [
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0]
            ],
            '0': [
                [0,1,1,1,0],
                [1,0,0,1,1],
                [1,0,1,0,1],
                [1,1,0,0,1],
                [1,0,1,0,1],
                [1,0,0,1,1],
                [0,1,1,1,0]
            ],
            '1': [
                [0,0,1,0,0],
                [0,1,1,0,0],
                [0,0,1,0,0],
                [0,0,1,0,0],
                [0,0,1,0,0],
                [0,0,1,0,0],
                [1,1,1,1,1]
            ],
            '2': [
                [0,1,1,1,0],
                [1,0,0,0,1],
                [0,0,0,0,1],
                [0,0,0,1,0],
                [0,0,1,0,0],
                [0,1,0,0,0],
                [1,1,1,1,1]
            ],
            '3': [
                [1,1,1,1,0],
                [0,0,0,0,1],
                [0,0,0,0,1],
                [0,1,1,1,0],
                [0,0,0,0,1],
                [0,0,0,0,1],
                [1,1,1,1,0]
            ],
            '4': [
                [1,0,0,1,0],
                [1,0,0,1,0],
                [1,0,0,1,0],
                [1,1,1,1,1],
                [0,0,0,1,0],
                [0,0,0,1,0],
                [0,0,0,1,0]
            ],
            '5': [
                [1,1,1,1,1],
                [1,0,0,0,0],
                [1,0,0,0,0],
                [1,1,1,1,0],
                [0,0,0,0,1],
                [0,0,0,0,1],
                [1,1,1,1,0]
            ],
            '6': [
                [0,1,1,1,0],
                [1,0,0,0,0],
                [1,0,0,0,0],
                [1,1,1,1,0],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [0,1,1,1,0]
            ],
            '7': [
                [1,1,1,1,1],
                [0,0,0,0,1],
                [0,0,0,1,0],
                [0,0,1,0,0],
                [0,1,0,0,0],
                [0,1,0,0,0],
                [0,1,0,0,0]
            ],
            '8': [
                [0,1,1,1,0],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [0,1,1,1,0],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [0,1,1,1,0]
            ],
            '9': [
                [0,1,1,1,0],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [0,1,1,1,1],
                [0,0,0,0,1],
                [0,0,0,0,1],
                [0,1,1,1,0]
            ],
            '!': [
                [0,0,1,0,0],
                [0,0,1,0,0],
                [0,0,1,0,0],
                [0,0,1,0,0],
                [0,0,1,0,0],
                [0,0,0,0,0],
                [0,0,1,0,0]
            ],
            '?': [
                [0,1,1,1,0],
                [1,0,0,0,1],
                [0,0,0,0,1],
                [0,0,0,1,0],
                [0,0,1,0,0],
                [0,0,0,0,0],
                [0,0,1,0,0]
            ],
            '.': [
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,1,0,0]
            ],
            ',': [
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,1,0,0],
                [0,1,0,0,0]
            ],
            ':': [
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,1,0,0],
                [0,0,0,0,0],
                [0,0,1,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0]
            ],
            ';': [
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,1,0,0],
                [0,0,0,0,0],
                [0,0,1,0,0],
                [0,0,1,0,0],
                [0,1,0,0,0]
            ],
            '-': [
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,1,1,1,0],
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0]
            ],
            '_': [
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0],
                [1,1,1,1,1]
            ],
            '+': [
                [0,0,0,0,0],
                [0,0,1,0,0],
                [0,0,1,0,0],
                [0,1,1,1,0],
                [0,0,1,0,0],
                [0,0,1,0,0],
                [0,0,0,0,0]
            ],
            '=': [
                [0,0,0,0,0],
                [0,0,0,0,0],
                [1,1,1,1,1],
                [0,0,0,0,0],
                [1,1,1,1,1],
                [0,0,0,0,0],
                [0,0,0,0,0]
            ],
            '/': [
                [0,0,0,0,1],
                [0,0,0,1,0],
                [0,0,1,0,0],
                [0,1,0,0,0],
                [1,0,0,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0]
            ],
            '\\': [
                [1,0,0,0,0],
                [0,1,0,0,0],
                [0,0,1,0,0],
                [0,0,0,1,0],
                [0,0,0,0,1],
                [0,0,0,0,0],
                [0,0,0,0,0]
            ],
            '(': [
                [0,0,1,0,0],
                [0,1,0,0,0],
                [0,1,0,0,0],
                [0,1,0,0,0],
                [0,1,0,0,0],
                [0,1,0,0,0],
                [0,0,1,0,0]
            ],
            ')': [
                [0,0,1,0,0],
                [0,0,0,1,0],
                [0,0,0,1,0],
                [0,0,0,1,0],
                [0,0,0,1,0],
                [0,0,0,1,0],
                [0,0,1,0,0]
            ],
            '[': [
                [0,1,1,1,0],
                [0,1,0,0,0],
                [0,1,0,0,0],
                [0,1,0,0,0],
                [0,1,0,0,0],
                [0,1,0,0,0],
                [0,1,1,1,0]
            ],
            ']': [
                [0,1,1,1,0],
                [0,0,0,1,0],
                [0,0,0,1,0],
                [0,0,0,1,0],
                [0,0,0,1,0],
                [0,0,0,1,0],
                [0,1,1,1,0]
            ],
            '{': [
                [0,0,1,1,0],
                [0,1,0,0,0],
                [0,1,0,0,0],
                [0,0,1,0,0],
                [0,1,0,0,0],
                [0,1,0,0,0],
                [0,0,1,1,0]
            ],
            '}': [
                [0,1,1,0,0],
                [0,0,0,1,0],
                [0,0,0,1,0],
                [0,0,1,0,0],
                [0,0,0,1,0],
                [0,0,0,1,0],
                [0,1,1,0,0]
            ],
            '<': [
                [0,0,0,1,0],
                [0,0,1,0,0],
                [0,1,0,0,0],
                [1,0,0,0,0],
                [0,1,0,0,0],
                [0,0,1,0,0],
                [0,0,0,1,0]
            ],
            '>': [
                [0,1,0,0,0],
                [0,0,1,0,0],
                [0,0,0,1,0],
                [0,0,0,0,1],
                [0,0,0,1,0],
                [0,0,1,0,0],
                [0,1,0,0,0]
            ],
            '"': [
                [1,0,1,0,0],
                [1,0,1,0,0],
                [1,0,1,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0]
            ],
            "'": [
                [0,0,1,0,0],
                [0,0,1,0,0],
                [0,0,1,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0]
            ],
            '`': [
                [0,1,0,0,0],
                [0,0,1,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0]
            ],
            '~': [
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,1,0,1,0],
                [1,0,1,0,1],
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0]
            ],
            '@': [
                [0,1,1,1,0],
                [1,0,0,0,1],
                [1,0,1,1,1],
                [1,0,1,0,1],
                [1,0,1,1,1],
                [1,0,0,0,0],
                [0,1,1,1,0]
            ],
            '#': [
                [0,1,0,1,0],
                [1,1,1,1,1],
                [0,1,0,1,0],
                [1,1,1,1,1],
                [0,1,0,1,0],
                [1,1,1,1,1],
                [0,1,0,1,0]
            ],
            '$': [
                [0,1,1,1,0],
                [1,0,0,0,1],
                [1,0,1,0,0],
                [0,1,1,1,0],
                [0,0,1,0,1],
                [1,0,0,0,1],
                [0,1,1,1,0]
            ],
            '%': [
                [1,0,0,0,1],
                [0,0,0,1,0],
                [0,0,1,0,0],
                [0,1,0,0,0],
                [0,0,1,0,0],
                [0,1,0,0,0],
                [1,0,0,0,1]
            ],
            '^': [
                [0,0,1,0,0],
                [0,1,0,1,0],
                [1,0,0,0,1],
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0],
                [0,0,0,0,0]
            ],
            '&': [
                [0,1,1,0,0],
                [1,0,0,1,0],
                [1,0,0,1,0],
                [0,1,1,0,0],
                [1,0,1,0,1],
                [1,0,0,1,0],
                [0,1,1,1,0]
            ],
            '*': [
                [0,0,0,0,0],
                [0,1,0,1,0],
                [0,0,1,0,0],
                [1,1,1,1,1],
                [0,0,1,0,0],
                [0,1,0,1,0],
                [0,0,0,0,0]
            ]
        };

        // Color palette with predefined colors
        const colorPalette = [
            '#FF9E80', '#FF5722', '#E91E63', '#9C27B0', '#673AB7',
            '#3F51B5', '#2196F3', '#03A9F4', '#00BCD4', '#009688',
            '#4CAF50', '#8BC34A', '#CDDC39', '#FFEB3B', '#FFC107',
            '#FF9800', '#795548', '#9E9E9E', '#607D8B', '#000000'
        ];

        // Gallery items
        const galleryItems = [
            { name: "Heart", data: [[0,1,1,0,0],[1,1,1,1,0],[1,1,1,1,1],[1,1,1,1,1],[0,1,1,1,0],[0,0,1,1,0],[0,0,0,1,0]] },
            { name: "Smile", data: [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,1,0,1,1],[1,0,0,0,1],[0,1,1,1,0]] },
            { name: "Star", data: [[0,0,1,0,0],[0,1,1,1,0],[1,1,1,1,1],[0,1,1,1,0],[1,1,1,1,1],[0,1,1,1,0],[0,0,1,0,0]] },
            { name: "Arrow", data: [[0,0,0,1,0],[0,0,1,1,0],[0,1,1,1,0],[1,1,1,1,1],[0,1,1,1,0],[0,0,1,1,0],[0,0,0,1,0]] },
            { name: "Diamond", data: [[0,0,1,0,0],[0,1,1,1,0],[1,1,1,1,1],[0,1,1,1,0],[0,0,1,0,0],[0,0,0,0,0],[0,0,0,0,0]] },
            { name: "Skull", data: [[0,1,1,1,0],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[0,1,1,1,0],[0,1,0,1,0],[0,1,1,1,0]] }
        ];

        // DOM elements
        const textInput = document.getElementById('textInput');
        const zoomSlider = document.getElementById('zoomSlider');
        const zoomValue = document.getElementById('zoomValue');
        const pixelDensitySlider = document.getElementById('pixelDensitySlider');
        const pixelDensityValue = document.getElementById('pixelDensityValue');
        const charSpacingSlider = document.getElementById('charSpacingSlider');
        const charSpacingValue = document.getElementById('charSpacingValue');
        const lineHeightSlider = document.getElementById('lineHeightSlider');
        const lineHeightValue = document.getElementById('lineHeightValue');
        const textColorPicker = document.getElementById('textColor');
        const bgColorPicker = document.getElementById('bgColor');
        const gridToggle = document.getElementById('gridToggle');
        const animationToggle = document.getElementById('animationToggle');
        const shadowToggle = document.getElementById('shadowToggle');
        const shadowX = document.getElementById('shadowX');
        const shadowY = document.getElementById('shadowY');
        const shadowBlur = document.getElementById('shadowBlur');
        const shadowXValue = document.getElementById('shadowXValue');
        const shadowYValue = document.getElementById('shadowYValue');
        const shadowBlurValue = document.getElementById('shadowBlurValue');
        const shadowColor = document.getElementById('shadowColor');
        const rotationSelect = document.getElementById('rotationSelect');
        const mirrorSelect = document.getElementById('mirrorSelect');
        const gradientToggle = document.getElementById('gradientToggle');
        const gradientColor = document.getElementById('gradientColor');
        const gradientPreview = document.getElementById('gradientPreview');
        const outlineToggle = document.getElementById('outlineToggle');
        const outlineColor = document.getElementById('outlineColor');
        const animationType = document.getElementById('animationType');
        const animationSpeed = document.getElementById('animationSpeed');
        const animationSpeedValue = document.getElementById('animationSpeedValue');
        const bgPattern = document.getElementById('bgPattern');
        const textAlign = document.getElementById('textAlign');
        const generateBtn = document.getElementById('generateBtn');
        const clearBtn = document.getElementById('clearBtn');
        const invertBtn = document.getElementById('invertBtn');
        const randomColorBtn = document.getElementById('randomColorBtn');
        const savePngBtn = document.getElementById('savePngBtn');
        const saveSvgBtn = document.getElementById('saveSvgBtn');
        const saveJsonBtn = document.getElementById('saveJsonBtn');
        const loadJsonBtn = document.getElementById('loadJsonBtn');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const autoSaveToggle = document.getElementById('autoSaveToggle');
        const batchProcessBtn = document.getElementById('batchProcessBtn');
        const runBatchBtn = document.getElementById('runBatchBtn');
        const asciiBtn = document.getElementById('asciiBtn');
        const copyAsciiBtn = document.getElementById('copyAsciiBtn');
        const pixelGrid = document.getElementById('pixelGrid');
        const copyNotification = document.getElementById('copyNotification');
        const asciiOutput = document.getElementById('asciiOutput');
        const asciiRepresentation = document.getElementById('asciiRepresentation');
        const gallery = document.getElementById('gallery');
        const historyPanel = document.getElementById('historyPanel');
        const customCharEditor = document.getElementById('customCharEditor');
        const customCharName = document.getElementById('customCharName');
        const charGrid = document.getElementById('charGrid');
        const saveCustomCharBtn = document.getElementById('saveCustomCharBtn');
        const batchProcessSection = document.getElementById('batchProcessSection');
        const batchTexts = document.getElementById('batchTexts');
        const batchResults = document.getElementById('batchResults');
        const colorPaletteContainer = document.getElementById('colorPalette');
        const spacingBar = document.getElementById('spacingBar');
        const saveStatus = document.getElementById('saveStatus');
        const autoSaveText = document.getElementById('autoSaveText');
        const textError = document.getElementById('textError');

        // Tab elements
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');

        // Set initial values
        pixelGrid.style.setProperty('--pixel-size', `${zoomSlider.value}px`);
        document.documentElement.style.setProperty('--text-color', textColorPicker.value);
        document.documentElement.style.setProperty('--bg-color', bgColorPicker.value);

        // Initialize custom characters
        let customCharacters = {};

        // Initialize history
        let history = [];
        const maxHistory = 10;

        // Initialize color palette
        function initColorPalette() {
            colorPaletteContainer.innerHTML = '';
            colorPalette.forEach(color => {
                const colorElement = document.createElement('div');
                colorElement.className = 'palette-color';
                colorElement.style.backgroundColor = color;
                colorElement.title = color;
                colorElement.addEventListener('click', () => {
                    textColorPicker.value = color;
                    document.documentElement.style.setProperty('--text-color', color);
                    updateGradientPreview();
                });
                colorPaletteContainer.appendChild(colorElement);
            });
        }

        // Initialize tab functionality
        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                const tabId = button.getAttribute('data-tab');
                
                // Deactivate all tabs
                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabContents.forEach(content => content.classList.remove('active'));
                
                // Activate selected tab
                button.classList.add('active');
                document.getElementById(`${tabId}-tab`).classList.add('active');
            });
        });

        // Initialize gallery
        function initGallery() {
            gallery.innerHTML = '';
            galleryItems.forEach((item, index) => {
                const galleryItem = document.createElement('div');
                galleryItem.className = 'gallery-item';
                galleryItem.textContent = item.name;
                galleryItem.addEventListener('click', () => {
                    textInput.value += `[${item.name}]`;
                    generatePixelText();
                });
                gallery.appendChild(galleryItem);
            });
        }

        // Initialize history panel
        function updateHistoryPanel() {
            historyPanel.innerHTML = '';
            if (history.length === 0) {
                historyPanel.innerHTML = '<p>No history yet. Generate some text!</p>';
                return;
            }
            
            history.forEach((item, index) => {
                const historyItem = document.createElement('div');
                historyItem.className = 'history-item';
                historyItem.innerHTML = `
                    <span>${item.text}</span>
                    <button class="secondary-btn" data-index="${index}">Load</button>
                `;
                historyItem.querySelector('button').addEventListener('click', () => {
                    loadFromHistory(index);
                });
                historyPanel.appendChild(historyItem);
            });
        }

        // Initialize custom character editor
        function initCustomCharEditor() {
            charGrid.innerHTML = '';
            for (let i = 0; i < 35; i++) {
                const charPixel = document.createElement('div');
                charPixel.className = 'char-pixel';
                charPixel.addEventListener('click', () => {
                    charPixel.classList.toggle('filled');
                });
                charGrid.appendChild(charPixel);
            }
        }

        // Load from history
        function loadFromHistory(index) {
            const item = history[index];
            textInput.value = item.text;
            textColorPicker.value = item.textColor;
            bgColorPicker.value = item.bgColor;
            pixelDensitySlider.value = item.pixelDensity;
            charSpacingSlider.value = item.charSpacing;
            lineHeightSlider.value = item.lineHeight;
            updatePixelSize();
            generatePixelText();
        }

        // Save to history
        function saveToHistory() {
            const item = {
                text: textInput.value,
                textColor: textColorPicker.value,
                bgColor: bgColorPicker.value,
                pixelDensity: pixelDensitySlider.value,
                charSpacing: charSpacingSlider.value,
                lineHeight: lineHeightSlider.value
            };
            
            history.unshift(item);
            if (history.length > maxHistory) {
                history.pop();
            }
            
            updateHistoryPanel();
        }

        // Update zoom display and CSS variable
        zoomSlider.addEventListener('input', () => {
            const zoom = zoomSlider.value;
            zoomValue.textContent = `${zoom}x`;
            updatePixelSize();
        });

        // Update pixel density display
        pixelDensitySlider.addEventListener('input', () => {
            const density = pixelDensitySlider.value;
            pixelDensityValue.textContent = `${density}x`;
        });

        // Update character spacing display
        charSpacingSlider.addEventListener('input', () => {
            const spacing = charSpacingSlider.value;
            charSpacingValue.textContent = spacing;
            // Update spacing visualization
            spacingBar.style.width = `${spacing * 20}%`;
        });

        // Update line height display
        lineHeightSlider.addEventListener('input', () => {
            const height = lineHeightSlider.value;
            lineHeightValue.textContent = height;
        });

        // Update shadow controls
        shadowX.addEventListener('input', () => {
            shadowXValue.textContent = `${shadowX.value}px`;
        });

        shadowY.addEventListener('input', () => {
            shadowYValue.textContent = `${shadowY.value}px`;
        });

        shadowBlur.addEventListener('input', () => {
            shadowBlurValue.textContent = `${shadowBlur.value}px`;
        });

        // Update animation speed
        animationSpeed.addEventListener('input', () => {
            animationSpeedValue.textContent = `${animationSpeed.value}x`;
        });

        // Update gradient preview
        function updateGradientPreview() {
            const color1 = textColorPicker.value;
            const color2 = gradientColor.value;
            gradientPreview.style.background = `linear-gradient(to right, ${color1}, ${color2})`;
        }

        textColorPicker.addEventListener('input', updateGradientPreview);
        gradientColor.addEventListener('input', updateGradientPreview);

        // Update pixel size based on zoom
        function updatePixelSize() {
            const zoom = parseInt(zoomSlider.value);
            pixelGrid.style.setProperty('--pixel-size', `${zoom}px`);
        }

        // Update text color
        textColorPicker.addEventListener('input', () => {
            const color = textColorPicker.value;
            document.documentElement.style.setProperty('--text-color', color);
            updateGradientPreview();
        });

        // Update background color
        bgColorPicker.addEventListener('input', () => {
            const color = bgColorPicker.value;
            document.documentElement.style.setProperty('--bg-color', color);
        });

        // Toggle grid lines
        gridToggle.addEventListener('change', () => {
            if (gridToggle.checked) {
                pixelGrid.style.gap = '1px';
            } else {
                pixelGrid.style.gap = '0';
            }
        });

        // Show copy notification
        function showCopyNotification(message = "Image saved!") {
            copyNotification.textContent = message;
            copyNotification.classList.add('show');
            setTimeout(() => {
                copyNotification.classList.remove('show');
            }, 2000);
        }

        // Generate random color
        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        // Validate text input
        function validateTextInput() {
            const text = textInput.value;
            if (text.length > 50) {
                textError.style.display = 'block';
                return false;
            } else {
                textError.style.display = 'none';
                return true;
            }
        }

        // Auto-save functionality
        function autoSave() {
            if (autoSaveToggle.checked) {
                saveStatus.classList.add('saving');
                setTimeout(() => {
                    saveToLocalStorage();
                    saveStatus.classList.remove('saving');
                }, 500);
            }
        }

        // Update auto-save text
        autoSaveToggle.addEventListener('change', () => {
            if (autoSaveToggle.checked) {
                autoSaveText.textContent = 'Auto-save: On';
                autoSave();
            } else {
                autoSaveText.textContent = 'Auto-save: Off';
            }
        });

        // Generate pixel text
        function generatePixelText() {
            if (!validateTextInput()) return;
            
            const text = textInput.value.toUpperCase();
            const density = parseInt(pixelDensitySlider.value);
            const charSpacing = parseInt(charSpacingSlider.value);
            const lineHeight = parseInt(lineHeightSlider.value);
            const animate = animationToggle.checked;
            const shadow = shadowToggle.checked;
            const shadowXVal = shadowX.value;
            const shadowYVal = shadowY.value;
            const shadowBlurVal = shadowBlur.value;
            const shadowColorVal = shadowColor.value;
            const rotation = parseInt(rotationSelect.value);
            const mirror = mirrorSelect.value;
            const gradient = gradientToggle.checked;
            const outline = outlineToggle.checked;
            const animType = animationType.value;
            const animSpeed = parseFloat(animationSpeed.value);
            const pattern = bgPattern.value;
            const align = textAlign.value;
            
            // Clear the grid
            pixelGrid.innerHTML = '';
            
            if (!text) return;
            
            // Apply rotation
            pixelGrid.style.transform = `rotate(${rotation}deg)`;
            
            // Split text into lines
            const lines = text.split('\n');
            
            // Calculate grid dimensions
            const charWidth = 5 * density;  // Width of each character in pixels
            const charHeight = 7 * density; // Height of each character in pixels
            const spacing = charSpacing * density; // Space between characters
            const lineSpacing = lineHeight * density; // Space between lines
            
            let maxLineWidth = 0;
            const lineData = [];
            
            // Process each line
            for (const line of lines) {
                const lineWidth = line.length * (charWidth + spacing) - spacing;
                maxLineWidth = Math.max(maxLineWidth, lineWidth);
                
                const linePixels = [];
                for (let row = 0; row < charHeight; row++) {
                    for (let col = 0; col < lineWidth; col++) {
                        // Determine which character this pixel belongs to
                        const charIndex = Math.floor(col / (charWidth + spacing));
                        const charCol = Math.floor((col % (charWidth + spacing)) / density);
                        
                        // If this is a spacing column, leave it empty
                        if (col % (charWidth + spacing) >= charWidth) {
                            linePixels.push(0);
                            continue;
                        }
                        
                        // Get the character
                        if (charIndex < line.length) {
                            const char = line[charIndex];
                            
                            // Check if it's a custom character
                            if (char.startsWith('[') && char.endsWith(']')) {
                                const charName = char.substring(1, char.length - 1);
                                const charData = customCharacters[charName];
                                
                                if (charData) {
                                    const densityRow = Math.floor(row / density);
                                    if (densityRow < charData.length && charData[densityRow][charCol] === 1) {
                                        linePixels.push(1);
                                    } else {
                                        linePixels.push(0);
                                    }
                                } else {
                                    // Try gallery items
                                    const galleryItem = galleryItems.find(item => item.name === charName);
                                    if (galleryItem) {
                                        const densityRow = Math.floor(row / density);
                                        if (densityRow < galleryItem.data.length && galleryItem.data[densityRow][charCol] === 1) {
                                            linePixels.push(1);
                                        } else {
                                            linePixels.push(0);
                                        }
                                    } else {
                                        linePixels.push(0);
                                    }
                                }
                            } else {
                                const charData = pixelAlphabet[char] || pixelAlphabet[' '];
                                const densityRow = Math.floor(row / density);
                                
                                // If this pixel should be filled
                                if (densityRow < charData.length && charData[densityRow][charCol] === 1) {
                                    linePixels.push(1);
                                } else {
                                    linePixels.push(0);
                                }
                            }
                        } else {
                            linePixels.push(0);
                        }
                    }
                }
                lineData.push(linePixels);
            }
            
            // Calculate total grid dimensions
            const gridWidth = maxLineWidth;
            const gridHeight = lines.length * charHeight + (lines.length - 1) * lineSpacing;
            
            // Set grid dimensions
            pixelGrid.style.gridTemplateColumns = `repeat(${gridWidth}, var(--pixel-size))`;
            
            // Apply background pattern
            if (pattern !== 'none') {
                applyBackgroundPattern(pattern, gridWidth, gridHeight);
            } else {
                pixelGrid.style.backgroundImage = 'none';
            }
            
            // Create pixels
            let pixelIndex = 0;
            for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                // Add line pixels
                for (let i = 0; i < lineData[lineIndex].length; i++) {
                    const pixel = document.createElement('div');
                    pixel.className = 'pixel';
                    
                    if (lineData[lineIndex][i] === 1) {
                        pixel.classList.add('filled');
                        
                        // Apply gradient
                        if (gradient) {
                            const gradientPercent = (i / lineData[lineIndex].length) * 100;
                            const color1 = textColorPicker.value;
                            const color2 = gradientColor.value;
                            pixel.style.background = `linear-gradient(to right, ${color1}, ${color2})`;
                            pixel.style.backgroundSize = `${lineData[lineIndex].length * 100}% 100%`;
                            pixel.style.backgroundPosition = `${gradientPercent}% 0`;
                        }
                        
                        // Apply outline
                        if (outline) {
                            pixel.style.border = `1px solid ${outlineColor.value}`;
                        }
                        
                        // Apply shadow
                        if (shadow) {
                            pixel.style.boxShadow = `${shadowXVal}px ${shadowYVal}px ${shadowBlurVal}px ${shadowColorVal}`;
                        }
                        
                        // Apply animation type
                        if (animType !== 'none') {
                            pixel.classList.add(animType);
                            // Apply animation speed
                            pixel.style.animationDuration = `${1 / animSpeed}s`;
                        }
                    }
                    
                    if (animate) {
                        pixel.style.animationDelay = `${pixelIndex * 0.01}s`;
                    } else {
                        pixel.style.opacity = '1';
                    }
                    
                    pixelGrid.appendChild(pixel);
                    pixelIndex++;
                }
                
                // Add line spacing
                if (lineIndex < lines.length - 1) {
                    for (let i = 0; i < lineSpacing; i++) {
                        const pixel = document.createElement('div');
                        pixel.className = 'pixel';
                        pixel.style.opacity = '1';
                        pixelGrid.appendChild(pixel);
                        pixelIndex++;
                    }
                }
            }
            
            // Apply mirroring
            if (mirror !== 'none') {
                applyMirroring(mirror);
            }
            
            // Apply text alignment
            if (align !== 'left') {
                applyTextAlignment(align, gridWidth);
            }
            
            // Save to history
            if (text.trim() !== '') {
                saveToHistory();
            }
            
            // Auto-save if enabled
            autoSave();
        }

        // Apply background pattern
        function applyBackgroundPattern(pattern, width, height) {
            const patternCanvas = document.createElement('canvas');
            patternCanvas.width = 20;
            patternCanvas.height = 20;
            const ctx = patternCanvas.getContext('2d');
            
            ctx.fillStyle = '#555';
            ctx.fillRect(0, 0, 20, 20);
            
            ctx.fillStyle = '#666';
            
            switch (pattern) {
                case 'dots':
                    ctx.beginPath();
                    ctx.arc(5, 5, 2, 0, Math.PI * 2);
                    ctx.arc(15, 15, 2, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'grid':
                    ctx.fillRect(0, 0, 20, 1);
                    ctx.fillRect(0, 0, 1, 20);
                    break;
                case 'diagonal':
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(20, 20);
                    ctx.moveTo(5, 0);
                    ctx.lineTo(20, 15);
                    ctx.moveTo(0, 5);
                    ctx.lineTo(15, 20);
                    ctx.stroke();
                    break;
            }
            
            const patternUrl = `url(${patternCanvas.toDataURL()})`;
            pixelGrid.style.backgroundImage = patternUrl;
        }

        // Apply mirroring
        function applyMirroring(mirror) {
            const pixels = pixelGrid.querySelectorAll('.pixel');
            const rows = parseInt(pixelGrid.style.gridTemplateColumns.match(/\d+/)[0]);
            
            if (mirror === 'horizontal' || mirror === 'both') {
                // Horizontal mirroring
                const newPixels = [];
                for (let i = 0; i < pixels.length; i += rows) {
                    const row = Array.from(pixels).slice(i, i + rows);
                    const mirroredRow = row.reverse();
                    newPixels.push(...mirroredRow);
                }
                
                pixelGrid.innerHTML = '';
                newPixels.forEach(pixel => pixelGrid.appendChild(pixel));
            }
            
            if (mirror === 'vertical' || mirror === 'both') {
                // Vertical mirroring
                const pixels = pixelGrid.querySelectorAll('.pixel');
                const newPixels = Array.from(pixels).reverse();
                
                pixelGrid.innerHTML = '';
                newPixels.forEach(pixel => pixelGrid.appendChild(pixel));
            }
        }

        // Apply text alignment
        function applyTextAlignment(align, gridWidth) {
            const pixels = pixelGrid.querySelectorAll('.pixel');
            const rows = parseInt(pixelGrid.style.gridTemplateColumns.match(/\d+/)[0]);
            
            if (align === 'center') {
                // Find the actual width of each line
                const lines = [];
                for (let i = 0; i < pixels.length; i += rows) {
                    const row = Array.from(pixels).slice(i, i + rows);
                    let lineWidth = 0;
                    
                    // Find the rightmost filled pixel
                    for (let j = row.length - 1; j >= 0; j--) {
                        if (row[j].classList.contains('filled')) {
                            lineWidth = j + 1;
                            break;
                        }
                    }
                    
                    lines.push({
                        startIndex: i,
                        width: lineWidth
                    });
                }
                
                // Calculate padding for each line
                lines.forEach(line => {
                    const padding = Math.floor((gridWidth - line.width) / 2);
                    
                    // Move pixels to the right by padding amount
                    for (let i = 0; i < line.width; i++) {
                        const sourceIndex = line.startIndex + i;
                        const targetIndex = line.startIndex + padding + i;
                        
                        if (targetIndex < line.startIndex + rows) {
                            // Swap pixels
                            const temp = pixels[targetIndex].className;
                            pixels[targetIndex].className = pixels[sourceIndex].className;
                            pixels[targetIndex].style.background = pixels[sourceIndex].style.background;
                            pixels[targetIndex].style.border = pixels[sourceIndex].style.border;
                            pixels[targetIndex].style.boxShadow = pixels[sourceIndex].style.boxShadow;
                            pixels[sourceIndex].className = 'pixel';
                            pixels[sourceIndex].style.background = '';
                            pixels[sourceIndex].style.border = '';
                            pixels[sourceIndex].style.boxShadow = '';
                        }
                    }
                });
            } else if (align === 'right') {
                // Find the actual width of each line
                const lines = [];
                for (let i = 0; i < pixels.length; i += rows) {
                    const row = Array.from(pixels).slice(i, i + rows);
                    let lineWidth = 0;
                    
                    // Find the rightmost filled pixel
                    for (let j = row.length - 1; j >= 0; j--) {
                        if (row[j].classList.contains('filled')) {
                            lineWidth = j + 1;
                            break;
                        }
                    }
                    
                    lines.push({
                        startIndex: i,
                        width: lineWidth
                    });
                }
                
                // Calculate padding for each line
                lines.forEach(line => {
                    const padding = gridWidth - line.width;
                    
                    // Move pixels to the right by padding amount
                    for (let i = line.width - 1; i >= 0; i--) {
                        const sourceIndex = line.startIndex + i;
                        const targetIndex = line.startIndex + padding + i;
                        
                        if (targetIndex < line.startIndex + rows) {
                            // Swap pixels
                            const temp = pixels[targetIndex].className;
                            pixels[targetIndex].className = pixels[sourceIndex].className;
                            pixels[targetIndex].style.background = pixels[sourceIndex].style.background;
                            pixels[targetIndex].style.border = pixels[sourceIndex].style.border;
                            pixels[targetIndex].style.boxShadow = pixels[sourceIndex].style.boxShadow;
                            pixels[sourceIndex].className = 'pixel';
                            pixels[sourceIndex].style.background = '';
                            pixels[sourceIndex].style.border = '';
                            pixels[sourceIndex].style.boxShadow = '';
                        }
                    }
                });
            }
        }

        // Clear the grid and input
        function clearGrid() {
            textInput.value = '';
            pixelGrid.innerHTML = '';
            asciiOutput.style.display = 'none';
        }

        // Invert colors
        function invertColors() {
            const textColor = textColorPicker.value;
            const bgColor = bgColorPicker.value;
            
            textColorPicker.value = bgColor;
            bgColorPicker.value = textColor;
            
            document.documentElement.style.setProperty('--text-color', bgColor);
            document.documentElement.style.setProperty('--bg-color', textColor);
            updateGradientPreview();
        }

        // Random colors
        function randomColors() {
            const textColor = getRandomColor();
            const bgColor = getRandomColor();
            
            textColorPicker.value = textColor;
            bgColorPicker.value = bgColor;
            
            document.documentElement.style.setProperty('--text-color', textColor);
            document.documentElement.style.setProperty('--bg-color', bgColor);
            updateGradientPreview();
        }

        // Save as PNG
        function saveAsPng() {
            const text = textInput.value.toUpperCase();
            if (!text) {
                return;
            }
            
            const density = parseInt(pixelDensitySlider.value);
            const charSpacing = parseInt(charSpacingSlider.value);
            const lineHeight = parseInt(lineHeightSlider.value);
            const shadow = shadowToggle.checked;
            const shadowXVal = shadowX.value;
            const shadowYVal = shadowY.value;
            const shadowBlurVal = shadowBlur.value;
            const shadowColorVal = shadowColor.value;
            const rotation = parseInt(rotationSelect.value);
            const mirror = mirrorSelect.value;
            const gradient = gradientToggle.checked;
            const outline = outlineToggle.checked;
            const pattern = bgPattern.value;
            
            // Split text into lines
            const lines = text.split('\n');
            
            // Calculate grid dimensions
            const charWidth = 5 * density;
            const charHeight = 7 * density;
            const spacing = charSpacing * density;
            const lineSpacing = lineHeight * density;
            
            let maxLineWidth = 0;
            
            // Calculate max line width
            for (const line of lines) {
                const lineWidth = line.length * (charWidth + spacing) - spacing;
                maxLineWidth = Math.max(maxLineWidth, lineWidth);
            }
            
            // Calculate total grid dimensions
            const gridWidth = maxLineWidth;
            const gridHeight = lines.length * charHeight + (lines.length - 1) * lineSpacing;
            
            // Create canvas
            let canvas = document.createElement('canvas');
            canvas.width = gridWidth;
            canvas.height = gridHeight;
            const ctx = canvas.getContext('2d');
            
            // Get colors
            const textColor = textColorPicker.value;
            const bgColor = bgColorPicker.value;
            const gradientColorValue = gradientColor.value;
            const outlineColorValue = outlineColor.value;
            
            // Fill background
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Apply background pattern
            if (pattern !== 'none') {
                const patternCanvas = document.createElement('canvas');
                patternCanvas.width = 20;
                patternCanvas.height = 20;
                const patternCtx = patternCanvas.getContext('2d');
                
                patternCtx.fillStyle = '#555';
                patternCtx.fillRect(0, 0, 20, 20);
                
                patternCtx.fillStyle = '#666';
                
                switch (pattern) {
                    case 'dots':
                        patternCtx.beginPath();
                        patternCtx.arc(5, 5, 2, 0, Math.PI * 2);
                        patternCtx.arc(15, 15, 2, 0, Math.PI * 2);
                        patternCtx.fill();
                        break;
                    case 'grid':
                        patternCtx.fillRect(0, 0, 20, 1);
                        patternCtx.fillRect(0, 0, 1, 20);
                        break;
                    case 'diagonal':
                        patternCtx.beginPath();
                        patternCtx.moveTo(0, 0);
                        patternCtx.lineTo(20, 20);
                        patternCtx.moveTo(5, 0);
                        patternCtx.lineTo(20, 15);
                        patternCtx.moveTo(0, 5);
                        patternCtx.lineTo(15, 20);
                        patternCtx.stroke();
                        break;
                }
                
                const patternUrl = ctx.createPattern(patternCanvas, 'repeat');
                ctx.fillStyle = patternUrl;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Create a temporary grid to hold the pixel data
            const pixelData = [];
            
            // Process each line
            for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                const line = lines[lineIndex];
                const lineWidth = line.length * (charWidth + spacing) - spacing;
                const yOffset = lineIndex * (charHeight + lineSpacing);
                
                for (let row = 0; row < charHeight; row++) {
                    for (let col = 0; col < lineWidth; col++) {
                        // Determine which character this pixel belongs to
                        const charIndex = Math.floor(col / (charWidth + spacing));
                        const charCol = Math.floor((col % (charWidth + spacing)) / density);
                        
                        // If this is a spacing column, skip
                        if (col % (charWidth + spacing) >= charWidth) {
                            continue;
                        }
                        
                        // Get the character
                        if (charIndex < line.length) {
                            const char = line[charIndex];
                            
                            // Check if it's a custom character
                            if (char.startsWith('[') && char.endsWith(']')) {
                                const charName = char.substring(1, char.length - 1);
                                const charData = customCharacters[charName];
                                
                                if (charData) {
                                    const densityRow = Math.floor(row / density);
                                    if (densityRow < charData.length && charData[densityRow][charCol] === 1) {
                                        pixelData.push({
                                            x: col,
                                            y: yOffset + row,
                                            color: textColor
                                        });
                                    }
                                } else {
                                    // Try gallery items
                                    const galleryItem = galleryItems.find(item => item.name === charName);
                                    if (galleryItem) {
                                        const densityRow = Math.floor(row / density);
                                        if (densityRow < galleryItem.data.length && galleryItem.data[densityRow][charCol] === 1) {
                                            pixelData.push({
                                                x: col,
                                                y: yOffset + row,
                                                color: textColor
                                            });
                                        }
                                    }
                                }
                            } else {
                                const charData = pixelAlphabet[char] || pixelAlphabet[' '];
                                const densityRow = Math.floor(row / density);
                                
                                // If this pixel should be filled
                                if (densityRow < charData.length && charData[densityRow][charCol] === 1) {
                                    pixelData.push({
                                        x: col,
                                        y: yOffset + row,
                                        color: textColor
                                    });
                                }
                            }
                        }
                    }
                }
            }
            
            // Apply mirroring to pixel data
            if (mirror !== 'none') {
                const mirroredData = [];
                
                if (mirror === 'horizontal' || mirror === 'both') {
                    // Horizontal mirroring
                    for (const pixel of pixelData) {
                        mirroredData.push({
                            x: gridWidth - pixel.x - 1,
                            y: pixel.y,
                            color: pixel.color
                        });
                    }
                    
                    if (mirror === 'horizontal') {
                        pixelData.length = 0;
                        pixelData.push(...mirroredData);
                    }
                }
                
                if (mirror === 'vertical' || mirror === 'both') {
                    // Vertical mirroring
                    const verticalData = [];
                    const sourceData = mirror === 'both' ? mirroredData : pixelData;
                    
                    for (const pixel of sourceData) {
                        verticalData.push({
                            x: pixel.x,
                            y: gridHeight - pixel.y - 1,
                            color: pixel.color
                        });
                    }
                    
                    pixelData.length = 0;
                    pixelData.push(...verticalData);
                }
            }
            
            // Apply text alignment to pixel data
            if (textAlign.value !== 'left') {
                // Find the actual width of each line
                const lines = [];
                for (let y = 0; y < gridHeight; y++) {
                    const linePixels = pixelData.filter(p => p.y === y);
                    let lineWidth = 0;
                    
                    if (linePixels.length > 0) {
                        lineWidth = Math.max(...linePixels.map(p => p.x)) + 1;
                    }
                    
                    lines.push({
                        y: y,
                        width: lineWidth
                    });
                }
                
                // Adjust pixel positions
                for (const line of lines) {
                    if (line.width > 0) {
                        let padding = 0;
                        
                        if (textAlign.value === 'center') {
                            padding = Math.floor((gridWidth - line.width) / 2);
                        } else if (textAlign.value === 'right') {
                            padding = gridWidth - line.width;
                        }
                        
                        // Move pixels to the right by padding amount
                        for (const pixel of pixelData) {
                            if (pixel.y === line.y) {
                                pixel.x += padding;
                            }
                        }
                    }
                }
            }
            
            // Draw pixels
            for (const pixel of pixelData) {
                // Apply gradient
                if (gradient) {
                    const gradient = ctx.createLinearGradient(0, 0, gridWidth, 0);
                    gradient.addColorStop(0, textColor);
                    gradient.addColorStop(1, gradientColorValue);
                    ctx.fillStyle = gradient;
                } else {
                    ctx.fillStyle = pixel.color;
                }
                
                // Draw pixel
                ctx.fillRect(pixel.x, pixel.y, 1, 1);
                
                // Apply outline
                if (outline) {
                    ctx.strokeStyle = outlineColorValue;
                    ctx.strokeRect(pixel.x, pixel.y, 1, 1);
                }
                
                // Apply shadow
                if (shadow) {
                    ctx.shadowColor = shadowColorVal;
                    ctx.shadowBlur = shadowBlurVal;
                    ctx.shadowOffsetX = shadowXVal;
                    ctx.shadowOffsetY = shadowYVal;
                    ctx.fillRect(pixel.x, pixel.y, 1, 1);
                    ctx.shadowColor = 'transparent';
                }
            }
            
            // Apply rotation
            if (rotation !== 0) {
                const rotatedCanvas = document.createElement('canvas');
                const rotatedCtx = rotatedCanvas.getContext('2d');
                
                if (rotation === 90 || rotation === 270) {
                    rotatedCanvas.width = canvas.height;
                    rotatedCanvas.height = canvas.width;
                } else {
                    rotatedCanvas.width = canvas.width;
                    rotatedCanvas.height = canvas.height;
                }
                
                rotatedCtx.translate(rotatedCanvas.width / 2, rotatedCanvas.height / 2);
                rotatedCtx.rotate((rotation * Math.PI) / 180);
                rotatedCtx.drawImage(canvas, -canvas.width / 2, -canvas.height / 2);
                
                canvas = rotatedCanvas;
            }
            
            // Convert to data URL and trigger download
            const dataUrl = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = 'peachy-pixel-text.png';
            link.href = dataUrl;
            link.click();
            
            showCopyNotification();
        }

        // Save as SVG
        function saveAsSvg() {
            const text = textInput.value.toUpperCase();
            if (!text) {
                return;
            }
            
            const density = parseInt(pixelDensitySlider.value);
            const charSpacing = parseInt(charSpacingSlider.value);
            const lineHeight = parseInt(lineHeightSlider.value);
            const shadow = shadowToggle.checked;
            const shadowXVal = shadowX.value;
            const shadowYVal = shadowY.value;
            const shadowBlurVal = shadowBlur.value;
            const shadowColorVal = shadowColor.value;
            const rotation = parseInt(rotationSelect.value);
            const mirror = mirrorSelect.value;
            const gradient = gradientToggle.checked;
            const outline = outlineToggle.checked;
            const pattern = bgPattern.value;
            
            // Split text into lines
            const lines = text.split('\n');
            
            // Calculate grid dimensions
            const charWidth = 5 * density;
            const charHeight = 7 * density;
            const spacing = charSpacing * density;
            const lineSpacing = lineHeight * density;
            
            let maxLineWidth = 0;
            
            // Calculate max line width
            for (const line of lines) {
                const lineWidth = line.length * (charWidth + spacing) - spacing;
                maxLineWidth = Math.max(maxLineWidth, lineWidth);
            }
            
            // Calculate total grid dimensions
            const gridWidth = maxLineWidth;
            const gridHeight = lines.length * charHeight + (lines.length - 1) * lineSpacing;
            
            // Create SVG
            let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${gridWidth}" height="${gridHeight}" viewBox="0 0 ${gridWidth} ${gridHeight}">`;
            
            // Add background
            svg += `<rect width="100%" height="100%" fill="${bgColorPicker.value}"/>`;
            
            // Add background pattern
            if (pattern !== 'none') {
                let patternDef = '';
                
                switch (pattern) {
                    case 'dots':
                        patternDef = `
                            <pattern id="dots" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse">
                                <rect width="20" height="20" fill="#555"/>
                                <circle cx="5" cy="5" r="2" fill="#666"/>
                                <circle cx="15" cy="15" r="2" fill="#666"/>
                            </pattern>
                        `;
                        break;
                    case 'grid':
                        patternDef = `
                            <pattern id="grid" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse">
                                <rect width="20" height="20" fill="#555"/>
                                <rect width="20" height="1" fill="#666"/>
                                <rect width="1" height="20" fill="#666"/>
                            </pattern>
                        `;
                        break;
                    case 'diagonal':
                        patternDef = `
                            <pattern id="diagonal" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse">
                                <rect width="20" height="20" fill="#555"/>
                                <path d="M0,0 L20,20 M5,0 L20,15 M0,5 L15,20" stroke="#666" stroke-width="1"/>
                            </pattern>
                        `;
                        break;
                }
                
                svg += `<defs>${patternDef}</defs>`;
                svg += `<rect width="100%" height="100%" fill="url(#${pattern})"/>`;
            }
            
            // Create a temporary grid to hold the pixel data
            const pixelData = [];
            
            // Process each line
            for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                const line = lines[lineIndex];
                const lineWidth = line.length * (charWidth + spacing) - spacing;
                const yOffset = lineIndex * (charHeight + lineSpacing);
                
                for (let row = 0; row < charHeight; row++) {
                    for (let col = 0; col < lineWidth; col++) {
                        // Determine which character this pixel belongs to
                        const charIndex = Math.floor(col / (charWidth + spacing));
                        const charCol = Math.floor((col % (charWidth + spacing)) / density);
                        
                        // If this is a spacing column, skip
                        if (col % (charWidth + spacing) >= charWidth) {
                            continue;
                        }
                        
                        // Get the character
                        if (charIndex < line.length) {
                            const char = line[charIndex];
                            
                            // Check if it's a custom character
                            if (char.startsWith('[') && char.endsWith(']')) {
                                const charName = char.substring(1, char.length - 1);
                                const charData = customCharacters[charName];
                                
                                if (charData) {
                                    const densityRow = Math.floor(row / density);
                                    if (densityRow < charData.length && charData[densityRow][charCol] === 1) {
                                        pixelData.push({
                                            x: col,
                                            y: yOffset + row,
                                            color: textColorPicker.value
                                        });
                                    }
                                } else {
                                    // Try gallery items
                                    const galleryItem = galleryItems.find(item => item.name === charName);
                                    if (galleryItem) {
                                        const densityRow = Math.floor(row / density);
                                        if (densityRow < galleryItem.data.length && galleryItem.data[densityRow][charCol] === 1) {
                                            pixelData.push({
                                                x: col,
                                                y: yOffset + row,
                                                color: textColorPicker.value
                                            });
                                        }
                                    }
                                }
                            } else {
                                const charData = pixelAlphabet[char] || pixelAlphabet[' '];
                                const densityRow = Math.floor(row / density);
                                
                                // If this pixel should be filled
                                if (densityRow < charData.length && charData[densityRow][charCol] === 1) {
                                    pixelData.push({
                                        x: col,
                                        y: yOffset + row,
                                        color: textColorPicker.value
                                    });
                                }
                            }
                        }
                    }
                }
            }
            
            // Apply mirroring to pixel data
            if (mirror !== 'none') {
                const mirroredData = [];
                
                if (mirror === 'horizontal' || mirror === 'both') {
                    // Horizontal mirroring
                    for (const pixel of pixelData) {
                        mirroredData.push({
                            x: gridWidth - pixel.x - 1,
                            y: pixel.y,
                            color: pixel.color
                        });
                    }
                    
                    if (mirror === 'horizontal') {
                        pixelData.length = 0;
                        pixelData.push(...mirroredData);
                    }
                }
                
                if (mirror === 'vertical' || mirror === 'both') {
                    // Vertical mirroring
                    const verticalData = [];
                    const sourceData = mirror === 'both' ? mirroredData : pixelData;
                    
                    for (const pixel of sourceData) {
                        verticalData.push({
                            x: pixel.x,
                            y: gridHeight - pixel.y - 1,
                            color: pixel.color
                        });
                    }
                    
                    pixelData.length = 0;
                    pixelData.push(...verticalData);
                }
            }
            
            // Apply text alignment to pixel data
            if (textAlign.value !== 'left') {
                // Find the actual width of each line
                const lines = [];
                for (let y = 0; y < gridHeight; y++) {
                    const linePixels = pixelData.filter(p => p.y === y);
                    let lineWidth = 0;
                    
                    if (linePixels.length > 0) {
                        lineWidth = Math.max(...linePixels.map(p => p.x)) + 1;
                    }
                    
                    lines.push({
                        y: y,
                        width: lineWidth
                    });
                }
                
                // Adjust pixel positions
                for (const line of lines) {
                    if (line.width > 0) {
                        let padding = 0;
                        
                        if (textAlign.value === 'center') {
                            padding = Math.floor((gridWidth - line.width) / 2);
                        } else if (textAlign.value === 'right') {
                            padding = gridWidth - line.width;
                        }
                        
                        // Move pixels to the right by padding amount
                        for (const pixel of pixelData) {
                            if (pixel.y === line.y) {
                                pixel.x += padding;
                            }
                        }
                    }
                }
            }
            
            // Add gradient definition if needed
            if (gradient) {
                svg += `
                    <defs>
                        <linearGradient id="textGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                            <stop offset="0%" style="stop-color:${textColorPicker.value};stop-opacity:1" />
                            <stop offset="100%" style="stop-color:${gradientColor.value};stop-opacity:1" />
                        </linearGradient>
                    </defs>
                `;
            }
            
            // Draw pixels
            for (const pixel of pixelData) {
                let fill = gradient ? 'url(#textGradient)' : pixel.color;
                
                svg += `<rect x="${pixel.x}" y="${pixel.y}" width="1" height="1" fill="${fill}"`;
                
                // Apply outline
                if (outline) {
                    svg += ` stroke="${outlineColor.value}" stroke-width="0.1"`;
                }
                
                // Apply shadow
                if (shadow) {
                    svg += ` filter="drop-shadow(${shadowXVal}px ${shadowYVal}px ${shadowBlurVal}px ${shadowColorVal})"`;
                }
                
                svg += `/>`;
            }
            
            // Apply rotation if needed
            if (rotation !== 0) {
                svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${gridWidth}" height="${gridHeight}" viewBox="0 0 ${gridWidth} ${gridHeight}">`;
                svg += `<g transform="rotate(${rotation} ${gridWidth/2} ${gridHeight/2})">`;
                
                // Re-add everything inside the transform group
                svg += `<rect width="100%" height="100%" fill="${bgColorPicker.value}"/>`;
                
                if (pattern !== 'none') {
                    svg += `<rect width="100%" height="100%" fill="url(#${pattern})"/>`;
                }
                
                for (const pixel of pixelData) {
                    let fill = gradient ? 'url(#textGradient)' : pixel.color;
                    
                    svg += `<rect x="${pixel.x}" y="${pixel.y}" width="1" height="1" fill="${fill}"`;
                    
                    if (outline) {
                        svg += ` stroke="${outlineColor.value}" stroke-width="0.1"`;
                    }
                    
                    if (shadow) {
                        svg += ` filter="drop-shadow(${shadowXVal}px ${shadowYVal}px ${shadowBlurVal}px ${shadowColorVal})"`;
                    }
                    
                    svg += `/>`;
                }
                
                svg += `</g>`;
            }
            
            svg += `</svg>`;
            
            // Create blob and trigger download
            const blob = new Blob([svg], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = 'peachy-pixel-text.svg';
            link.href = url;
            link.click();
            
            showCopyNotification("SVG saved!");
        }

        // Save as JSON
        function saveAsJson() {
            const data = {
                text: textInput.value,
                textColor: textColorPicker.value,
                bgColor: bgColorPicker.value,
                pixelDensity: pixelDensitySlider.value,
                charSpacing: charSpacingSlider.value,
                lineHeight: lineHeightSlider.value,
                shadow: shadowToggle.checked,
                shadowX: shadowX.value,
                shadowY: shadowY.value,
                shadowBlur: shadowBlur.value,
                shadowColor: shadowColor.value,
                rotation: rotationSelect.value,
                mirror: mirrorSelect.value,
                gradient: gradientToggle.checked,
                gradientColor: gradientColor.value,
                outline: outlineToggle.checked,
                outlineColor: outlineColor.value,
                animationType: animationType.value,
                animationSpeed: animationSpeed.value,
                bgPattern: bgPattern.value,
                textAlign: textAlign.value,
                customCharacters: customCharacters
            };
            
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = 'peachy-pixel-text.json';
            link.href = url;
            link.click();
            
            showCopyNotification("JSON saved!");
        }

        // Load from JSON
        function loadFromJson() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = e => {
                const file = e.target.files[0];
                const reader = new FileReader();
                
                reader.onload = event => {
                    try {
                        const data = JSON.parse(event.target.result);
                        
                        // Apply loaded settings
                        textInput.value = data.text || '';
                        textColorPicker.value = data.textColor || '#FF9E80';
                        bgColorPicker.value = data.bgColor || '#444444';
                        pixelDensitySlider.value = data.pixelDensity || 1;
                        charSpacingSlider.value = data.charSpacing || 1;
                        lineHeightSlider.value = data.lineHeight || 0;
                        shadowToggle.checked = data.shadow || false;
                        shadowX.value = data.shadowX || 2;
                        shadowY.value = data.shadowY || 2;
                        shadowBlur.value = data.shadowBlur || 4;
                        shadowColor.value = data.shadowColor || '#000000';
                        rotationSelect.value = data.rotation || 0;
                        mirrorSelect.value = data.mirror || 'none';
                        gradientToggle.checked = data.gradient || false;
                        gradientColor.value = data.gradientColor || '#FF5722';
                        outlineToggle.checked = data.outline || false;
                        outlineColor.value = data.outlineColor || '#FFFFFF';
                        animationType.value = data.animationType || 'none';
                        animationSpeed.value = data.animationSpeed || 1;
                        bgPattern.value = data.bgPattern || 'none';
                        textAlign.value = data.textAlign || 'left';
                        
                        // Update displays
                        pixelDensityValue.textContent = `${pixelDensitySlider.value}x`;
                        charSpacingValue.textContent = charSpacingSlider.value;
                        lineHeightValue.textContent = lineHeightSlider.value;
                        shadowXValue.textContent = `${shadowX.value}px`;
                        shadowYValue.textContent = `${shadowY.value}px`;
                        shadowBlurValue.textContent = `${shadowBlur.value}px`;
                        animationSpeedValue.textContent = `${animationSpeed.value}x`;
                        updateGradientPreview();
                        
                        // Load custom characters
                        if (data.customCharacters) {
                            customCharacters = data.customCharacters;
                        }
                        
                        // Generate the pixel text
                        generatePixelText();
                        
                        showCopyNotification("JSON loaded!");
                    } catch (error) {
                        showCopyNotification("Error loading JSON!");
                        console.error(error);
                    }
                };
                
                reader.readAsText(file);
            };
            
            input.click();
        }

        // Save to local storage
        function saveToLocalStorage() {
            const data = {
                text: textInput.value,
                textColor: textColorPicker.value,
                bgColor: bgColorPicker.value,
                pixelDensity: pixelDensitySlider.value,
                charSpacing: charSpacingSlider.value,
                lineHeight: lineHeightSlider.value,
                shadow: shadowToggle.checked,
                shadowX: shadowX.value,
                shadowY: shadowY.value,
                shadowBlur: shadowBlur.value,
                shadowColor: shadowColor.value,
                rotation: rotationSelect.value,
                mirror: mirrorSelect.value,
                gradient: gradientToggle.checked,
                gradientColor: gradientColor.value,
                outline: outlineToggle.checked,
                outlineColor: outlineColor.value,
                animationType: animationType.value,
                animationSpeed: animationSpeed.value,
                bgPattern: bgPattern.value,
                textAlign: textAlign.value,
                customCharacters: customCharacters,
                history: history
            };
            
            localStorage.setItem('peachyPixelProData', JSON.stringify(data));
        }

        // Load from local storage
        function loadFromLocalStorage() {
            const savedData = localStorage.getItem('peachyPixelProData');
            
            if (savedData) {
                try {
                    const data = JSON.parse(savedData);
                    
                    // Apply loaded settings
                    textInput.value = data.text || '';
                    textColorPicker.value = data.textColor || '#FF9E80';
                    bgColorPicker.value = data.bgColor || '#444444';
                    pixelDensitySlider.value = data.pixelDensity || 1;
                    charSpacingSlider.value = data.charSpacing || 1;
                    lineHeightSlider.value = data.lineHeight || 0;
                    shadowToggle.checked = data.shadow || false;
                    shadowX.value = data.shadowX || 2;
                    shadowY.value = data.shadowY || 2;
                    shadowBlur.value = data.shadowBlur || 4;
                    shadowColor.value = data.shadowColor || '#000000';
                    rotationSelect.value = data.rotation || 0;
                    mirrorSelect.value = data.mirror || 'none';
                    gradientToggle.checked = data.gradient || false;
                    gradientColor.value = data.gradientColor || '#FF5722';
                    outlineToggle.checked = data.outline || false;
                    outlineColor.value = data.outlineColor || '#FFFFFF';
                    animationType.value = data.animationType || 'none';
                    animationSpeed.value = data.animationSpeed || 1;
                    bgPattern.value = data.bgPattern || 'none';
                    textAlign.value = data.textAlign || 'left';
                    autoSaveToggle.checked = true;
                    
                    // Update displays
                    pixelDensityValue.textContent = `${pixelDensitySlider.value}x`;
                    charSpacingValue.textContent = charSpacingSlider.value;
                    lineHeightValue.textContent = lineHeightSlider.value;
                    shadowXValue.textContent = `${shadowX.value}px`;
                    shadowYValue.textContent = `${shadowY.value}px`;
                    shadowBlurValue.textContent = `${shadowBlur.value}px`;
                    animationSpeedValue.textContent = `${animationSpeed.value}x`;
                    updateGradientPreview();
                    
                    // Load custom characters
                    if (data.customCharacters) {
                        customCharacters = data.customCharacters;
                    }
                    
                    // Load history
                    if (data.history) {
                        history = data.history;
                        updateHistoryPanel();
                    }
                    
                    // Generate the pixel text
                    generatePixelText();
                } catch (error) {
                    console.error('Error loading from local storage:', error);
                }
            }
        }

        // Fullscreen mode
        function toggleFullscreen() {
            const gridContainer = document.querySelector('.grid-container');
            
            if (!document.fullscreenElement) {
                const fullscreenDiv = document.createElement('div');
                fullscreenDiv.className = 'fullscreen';
                
                const exitBtn = document.createElement('button');
                exitBtn.className = 'exit-fullscreen';
                exitBtn.textContent = 'Exit Fullscreen';
                exitBtn.addEventListener('click', toggleFullscreen);
                
                fullscreenDiv.appendChild(exitBtn);
                fullscreenDiv.appendChild(gridContainer.cloneNode(true));
                document.body.appendChild(fullscreenDiv);
                
                if (fullscreenDiv.requestFullscreen) {
                    fullscreenDiv.requestFullscreen();
                } else if (fullscreenDiv.webkitRequestFullscreen) {
                    fullscreenDiv.webkitRequestFullscreen();
                } else if (fullscreenDiv.msRequestFullscreen) {
                    fullscreenDiv.msRequestFullscreen();
                }
            } else {
                document.exitFullscreen();
                setTimeout(() => {
                    const fullscreenDiv = document.querySelector('.fullscreen');
                    if (fullscreenDiv) {
                        fullscreenDiv.remove();
                    }
                }, 100);
            }
        }

        // Batch processing
        function toggleBatchProcess() {
            if (batchProcessSection.style.display === 'none') {
                batchProcessSection.style.display = 'block';
            } else {
                batchProcessSection.style.display = 'none';
            }
        }

        function runBatchProcess() {
            const texts = batchTexts.value.split('\n').filter(text => text.trim() !== '');
            batchResults.innerHTML = '';
            
            texts.forEach((text, index) => {
                const batchItem = document.createElement('div');
                batchItem.className = 'batch-item';
                
                const batchGrid = document.createElement('div');
                batchGrid.className = 'pixel-grid';
                batchGrid.style.gridTemplateColumns = `repeat(${text.length * 6}, 10px)`;
                
                // Generate pixel text for this item
                for (let i = 0; i < text.length; i++) {
                    const char = text[i].toUpperCase();
                    const charData = pixelAlphabet[char] || pixelAlphabet[' '];
                    
                    for (let row = 0; row < 7; row++) {
                        for (let col = 0; col < 5; col++) {
                            const pixel = document.createElement('div');
                            pixel.className = 'pixel';
                            pixel.style.width = '10px';
                            pixel.style.height = '10px';
                            
                            if (charData[row][col] === 1) {
                                pixel.classList.add('filled');
                                pixel.style.backgroundColor = textColorPicker.value;
                            }
                            
                            batchGrid.appendChild(pixel);
                        }
                    }
                    
                    // Add spacing
                    const spacePixel = document.createElement('div');
                    spacePixel.className = 'pixel';
                    spacePixel.style.width = '10px';
                    spacePixel.style.height = '10px';
                    batchGrid.appendChild(spacePixel);
                }
                
                batchItem.appendChild(batchGrid);
                batchItem.appendChild(document.createElement('br'));
                batchItem.appendChild(document.createTextNode(text));
                
                batchResults.appendChild(batchItem);
            });
            
            showCopyNotification("Batch processed!");
        }

        // Save custom character
        function saveCustomCharacter() {
            const name = customCharName.value.trim();
            if (!name) {
                showCopyNotification("Please enter a name for your character!");
                return;
            }
            
            const charPixels = charGrid.querySelectorAll('.char-pixel');
            const charData = [];
            
            for (let row = 0; row < 7; row++) {
                const rowData = [];
                for (let col = 0; col < 5; col++) {
                    const index = row * 5 + col;
                    rowData.push(charPixels[index].classList.contains('filled') ? 1 : 0);
                }
                charData.push(rowData);
            }
            
            customCharacters[name] = charData;
            
            // Add to gallery
            const galleryItem = document.createElement('div');
            galleryItem.className = 'gallery-item';
            galleryItem.textContent = name;
            galleryItem.addEventListener('click', () => {
                textInput.value += `[${name}]`;
                generatePixelText();
            });
            gallery.appendChild(galleryItem);
            
            // Reset editor
            customCharName.value = '';
            initCustomCharEditor();
            
            showCopyNotification("Character saved!");
        }

        // Export as ASCII
        function exportAsAscii() {
            const text = textInput.value.toUpperCase();
            if (!text) {
                return;
            }
            
            // Split text into lines
            const lines = text.split('\n');
            
            let asciiArt = '';
            
            // Process each line
            for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                const line = lines[lineIndex];
                
                // Process each row of the character
                for (let row = 0; row < 7; row++) {
                    for (let charIndex = 0; charIndex < line.length; charIndex++) {
                        const char = line[charIndex];
                        
                        // Check if it's a custom character
                        if (char.startsWith('[') && char.endsWith(']')) {
                            const charName = char.substring(1, char.length - 1);
                            const charData = customCharacters[charName];
                            
                            if (charData) {
                                // Add character spacing
                                if (charIndex > 0) {
                                    asciiArt += ' ';
                                }
                                
                                // Process each column of the character
                                for (let col = 0; col < 5; col++) {
                                    if (charData[row][col] === 1) {
                                        asciiArt += '';
                                    } else {
                                        asciiArt += ' ';
                                    }
                                }
                            } else {
                                // Try gallery items
                                const galleryItem = galleryItems.find(item => item.name === charName);
                                if (galleryItem) {
                                    // Add character spacing
                                    if (charIndex > 0) {
                                        asciiArt += ' ';
                                    }
                                    
                                    // Process each column of the character
                                    for (let col = 0; col < 5; col++) {
                                        if (galleryItem.data[row][col] === 1) {
                                            asciiArt += '';
                                        } else {
                                            asciiArt += ' ';
                                        }
                                    }
                                } else {
                                    // Add character spacing
                                    if (charIndex > 0) {
                                        asciiArt += ' ';
                                    }
                                    
                                    // Add empty space for unknown character
                                    for (let col = 0; col < 5; col++) {
                                        asciiArt += ' ';
                                    }
                                }
                            }
                        } else {
                            const charData = pixelAlphabet[char] || pixelAlphabet[' '];
                            
                            // Add character spacing
                            if (charIndex > 0) {
                                asciiArt += ' ';
                            }
                            
                            // Process each column of the character
                            for (let col = 0; col < 5; col++) {
                                if (charData[row][col] === 1) {
                                    asciiArt += '';
                                } else {
                                    asciiArt += ' ';
                                }
                            }
                        }
                    }
                    asciiArt += '\n';
                }
                
                // Add line spacing
                if (lineIndex < lines.length - 1) {
                    asciiArt += '\n';
                }
            }
            
            // Display ASCII art
            asciiRepresentation.textContent = asciiArt;
            asciiOutput.style.display = 'block';
        }

        // Copy ASCII to clipboard
        function copyAsciiToClipboard() {
            const text = asciiRepresentation.textContent;
            navigator.clipboard.writeText(text).then(() => {
                showCopyNotification("ASCII copied to clipboard!");
            }).catch(err => {
                console.error('Failed to copy text: ', err);
            });
        }

        // Event listeners
        generateBtn.addEventListener('click', generatePixelText);
        textInput.addEventListener('input', generatePixelText);
        clearBtn.addEventListener('click', clearGrid);
        invertBtn.addEventListener('click', invertColors);
        randomColorBtn.addEventListener('click', randomColors);
        savePngBtn.addEventListener('click', saveAsPng);
        saveSvgBtn.addEventListener('click', saveAsSvg);
        saveJsonBtn.addEventListener('click', saveAsJson);
        loadJsonBtn.addEventListener('click', loadFromJson);
        fullscreenBtn.addEventListener('click', toggleFullscreen);
        batchProcessBtn.addEventListener('click', toggleBatchProcess);
        runBatchBtn.addEventListener('click', runBatchProcess);
        asciiBtn.addEventListener('click', exportAsAscii);
        copyAsciiBtn.addEventListener('click', copyAsciiToClipboard);
        saveCustomCharBtn.addEventListener('click', saveCustomCharacter);

        // Initialize
        updatePixelSize();
        initGallery();
        updateHistoryPanel();
        initCustomCharEditor();
        initColorPalette();
        updateGradientPreview();
        loadFromLocalStorage();

        // Add keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ctrl/Cmd + Enter: Generate
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                generatePixelText();
            }
            
            // Ctrl/Cmd + S: Save as PNG
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                saveAsPng();
            }
            
            // Ctrl/Cmd + I: Invert colors
            if ((e.ctrlKey || e.metaKey) && e.key === 'i') {
                e.preventDefault();
                invertColors();
            }
            
            // Ctrl/Cmd + R: Random colors
            if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
                e.preventDefault();
                randomColors();
            }
            
            // Ctrl/Cmd + D: Clear
            if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
                e.preventDefault();
                clearGrid();
            }
            
            // Escape: Exit fullscreen
            if (e.key === 'Escape' && document.fullscreenElement) {
                toggleFullscreen();
            }
        });

        // Initial generation
        generatePixelText();
    </script>
</body>
</html>
